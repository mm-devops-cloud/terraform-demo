بسم الله الرحمن الرحيم 
Terraform 

1 - introduction 
    {
        - we can search for any provider we need to use on this link "https://registry.terraform.io/"
        also there is doc for each one 
        - we will use aws provider 
    }
2 - step one :
    {
        * we can add this as option if we will use more than one provider
            (
                terraform {
                    required_providers {
                        aws = {
                        source = "hashicorp/aws"
                        version = "4.55.0"
                        }
                    }
                }
            )
            - for this is best practice is create file and add the code up on that file like provider.tf 
            - also this code is required if i use provider not from hashicorp , because here i will mention the source for provider.

        * and after that we will add provider configuration like this
            (
                provider "aws" {
                    region = "us-east-2"
                    access_key = "AKIA3YRWOJXGMZRPHKNS"
                    secret_key = "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"
                }
            )
            - this not recommended to use key on file configuration
        * after that we will use command to download all required file for aws provider
            # terraform init 
          - this will download file to run aws provider
    }
3 - step two :
    {
        (
            provider "aws" {
                region = "us-east-2"
                access_key = "AKIA3YRWOJXGMZRPHKNS"
                secret_key = "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"
            } 

            resource "aws_vpc" "MM" {    # here we create a resource vpc and we named MM and put tags and cidr_block for this vpc
            cidr_block = "99.0.0.0/16"
            tags = {
                Name = "MM"
            }
            enable_dns_hostnames = true # those options we can find on docs
            
            }

            resource "aws_subnet" "MM-sub-1" {
            vpc_id     = aws_vpc.MM.id # we can refrence the id of any resource by usind resource type + name of resource + id
            cidr_block = "99.0.1.0/24"
            availability_zone = "us-east-2a"
            tags = {
                Name = "MM-sub-1"
            }

            }
        )
    * then we will apply this configuration using command :
        # terraform apply

    
    * there is type (Data) this provider gives us ability to get information about resources already existing
        like if i need to add subnet to existing vpc i need vpc id so i will not use (source type + name of source + id) because this for 
        not existing vpc but i will use (data)
        (
                data "aws_vpc" "existing_vpc" {
                tags = {
                    Name = "MM"
                }
                }
                resource "aws_subnet" "MM-sub-2" {
                vpc_id     = data.aws_vpc.existing_subnet.id
                cidr_block = "99.0.2.0/24"
                availability_zone = "us-east-2a"
                tags = {
                    Name = "MM-sub-2"
                }
                }
        )
        here we use data to get id of vpc using tags to get id , we can use multiple thing to search we can check that on docs
        under name "Argument Reference"
        and after that we use "data.aws_vpc.existing_vpc" to get that id and use on add new subnet
    }
3 - step three :
    * to remove resource we have two methods one remove code form file or we can use command destroy 
    {
        # terraform destroy -target aws_subnet.MM-sub-2
        here we will pass for target the resource name with type of resource 
    }
    but best practice is use through the file mean i can command the code or delete from file and 
    use terraform apply to remove that code command in file .

    * if i need to see what is already apply before we can use command 
        # terraform plan
    * if i need to deploy without ask to approve yes/no i can use this flag 
        # terraform apply -auto-approve
    * if we need to destroy all infrastructure we create by file we can use this command
        # terraform destroy
    * to know state of resources we have 2 file name " terraform.tfstate" and "terraform.tfstate.backup"
        the state will store here , also we can use command to know the state
        # terraform state list
            this to list all resources 
        # terraform state show aws_subnet.MM-sub-1
            this to show specific resources .. this important to know the value is generated by
            aws and not showing on file i write for deploy like " if create ec2 , and i need to know ip of that server"

            - also we can use "OutPut" in configuration file to get that value for resource i create
                each attribute we need OutPut we can't use one OutPut for 2 attributes even from same resource
                (
                    output "dev-vpc-id" {
                    value = aws_vpc.MM.id
                    
                    }
                    output "dev-vpc-owner" {
                    value = aws_vpc.MM.owner_id
                    
                    }
                )

                the result will be like this after applying file :
                (
                    Apply complete! Resources: 2 added, 0 changed, 0 destroyed.

                    Outputs:

                    dev-vpc-id = "vpc-0c5fc47c3d3e46520"
                    dev-vpc-owner = "808641777100"
                )
    * we can use variables in file to be the code reuseable again :
        (
            variable "subnet_cider_block" {
                description = "this for cider block"
                
                }
                - this definition of variable on top of file and then we will use on code like 

            resource "aws_subnet" "MM-sub-1" {
                vpc_id     = aws_vpc.MM.id 
                cidr_block = var.subnet_cider_block  # here we map variable to cider block
                availability_zone = "us-east-2a"
                tags = {
                    Name = "MM-sub-1"
                    env = "dev"
                }

                }
        )
        - to enter variable value we have 3 way :
            1- when we use "terraform apply" then he will ask me to enter value of variable
            2- we can use command to pass value of variable " terraform apply -var "subnet_cider_block=10.0.1.0/24"  "
            3- this for best practice is using file to store all variables and values in the file
                the name should be is "terraform.tfvars" this name the terraform will recognize is file for store variables
                if we change name of file like i have 3 file for 3 environment like (terraform-dev.tfvars , terraform-prod.tfvars, terraform-stage.tfvars)
                i need to pass file name when apply the terraform 
                    # terraform apply -var-file terraform-dev.tfvars

                on file we will store key value for variable like 
                subnet_cider_block = "99.0.5.0/24"
                and after that just apply no need to mention var or any thing
        - we can define default value for variable .. to use if not find value in file or not pass in command 
            (
                variable "subnet_cider_block" {
                    description = "this for cider block"
                    default = "99.0.5.0/24"
                    type= string
                }
            )
        - we can specify type for variable .. like (string , list , number , ... )
            example 1 :
                (
                    - in file we will add this line 
                        cider_blocks = ["10.0.0.0/16","10.0.10.0/24"]
                    - then on terraform code will define variable and type list
                        variable "cider_blocks" {
                            description = "this for cider blocks"
                            type = list(string)
                            
                            }
                    - then on resource will mention variable "cider_blocks" 
                        resource "aws_vpc" "MM" {    # here we create a resource vpc and we named MM and put tags and cidr_block for this vpc
                            cidr_block = var.cider_blocks[0] # here mean first value in list
                            tags = {
                                Name = "MM"
                                env = "dev"
                            }
                            enable_dns_hostnames = true  # those options we can find on docs
                            
                            }
                )
            example 2 :
                (
                    - we will use objects on list ..first we will add values on terraform.tfvars
                        "
                            cider_blocks = [
                                            {cider_block = "99.0.0.0/16", name = "my-vpc-dev"} ,
                                            {cider_block = "99.0.50.0/24" , name = "my-subnet-1"}
                                        ]                          
                        "
                    - then we need to define the variable in code file 
                        "
                            variable "cider_blocks" {
                                description = "this for cider blocks"
                                type = list(object({
                                    cider_block = string
                                    name = string
                                }))
                                
                                }
                        "
                        here we said there list and inside list there is object , and each object have 2
                        variable name cider_block and name , and both of them as strings
                    - now we can map the variable in code file
                        "
                            resource "aws_subnet" "MM-sub-1" {
                                vpc_id     = aws_vpc.MM.id # we can refrence the id of any resource by usind resource type + name of resource + id
                                cidr_block = var.cider_blocks[1].cider_block # here we mention the value of cider_block
                                # cidr_block = "99.0.1.0/24"
                                availability_zone = "us-east-2a"
                                tags = {
                                    Name = var.cider_blocks[1].name #here we mention that name here
                                    env = var.environment
                                }

                                }
                        "
                )
4 - step four :
    {
        * we will create project on aws ,
            - first we will add variables to let code more reuseable 
                (
                    variable "vpc_cider_block" {}
                    variable "subnet_cider_block" {}
                    variable "env_prefix" {}

                )
                and we will add value of variable on terraform.tfvars
                (
                    vpc_cider_block = "99.0.0.0/16"
                    subnet_cider_block = "99.0.15.0/24"
                    env_prefix = "production"
                )
            - then we will create vpc 
                (
                    resource "aws_vpc" "MM" {    # here we create a resource vpc and we named MM and put tags and cidr_block for this vpc
                        cidr_block = var.vpc_cider_block 
                        enable_dns_hostnames = true  # those options we can find on docs
                        tags = {
                            Name = "${var.env_prefix}-vpc-MM"
                        }
                        
                        }
                )
            - then we will create a new subnet on this vpc
                (
                    resource "aws_subnet" "MM-sub-1" {
                        vpc_id     = aws_vpc.MM.id # we can refrence the id of any resource by usind resource type + name of resource + id
                        cidr_block = var.subnet_cider_block
                        availability_zone = "us-east-2a"
                        tags = {
                            Name = "${var.env_prefix}-subnet-MM-1"
                        }
                        }
                )
            - then we will create internet gateway and add default route 0.0.0.0/0 to this igw
                (
                    resource "aws_internet_gateway" "MM_GW" {
                        vpc_id = aws_vpc.MM.id
                        tags = {
                            Name = "${var.env_prefix}-GW-MM"
                        }
                        
                        }
                )
            - then we will create a new route table or we can use default route table but now we will add new one 
              and we will make default route to igw 
                (
                    resource "aws_route_table" "MM_route_table" {
                        vpc_id = aws_vpc.MM.id
                        route  {
                            cidr_block = "0.0.0.0/0"
                            gateway_id = aws_internet_gateway.MM_GW.id
                        }
                        tags = {
                            Name = "${var.env_prefix}-route-table-MM"
                        }
                        }
                )
            - then we will associate the subnet with the route table 
                (
                    resource "aws_route_table_association" "MM-sub-1_route_table" {
                        subnet_id      = aws_subnet.MM-sub-1.id
                        route_table_id = aws_route_table.MM_route_table.id
                        }
                )
            * we can use the default route table without add new route table
                - first we will keep igw and we will remove that associated route table and new route table i create before
                - then i need to know what the id of the route table is existing i will use command 
                    #terraform state show aws_vpc.MM
                    this command will show me all resources created for this vpc by default we will copy the "default_route_table_id"
                - then i will use this id i get on code 
                    (
                        resource "aws_default_route_table" "default_MM_rt" {
                            default_route_table_id = aws_vpc.MM.default_route_table_id

                            route {
                                cidr_block = "0.0.0.0/0"
                                gateway_id = aws_internet_gateway.MM_GW.id
                            }
                            }
                    )
            - then we will add security group for server .. in security group we can add rule 
                (
                    resource "aws_security_group" "sg_MM" {
                        name        = "sg_MM"
                        description = "Allow inbound traffic"
                        vpc_id      = aws_vpc.MM.id
                        ingress {
                            from_port        = 22 # here i can make range of ports like on from_port i will put 1 and to_port i will put 1000 if i need to open form 1 to 1000 range
                            to_port          = 22
                            protocol         = "tcp"
                            cidr_blocks      = [var.my_ip]
                        }

                        ingress {
                            from_port        = 8080 # here i can make range of ports like on from_port i will put 1 and to_port i will put 1000 if i need to open form 1 to 1000 range
                            to_port          = 8080
                            protocol         = "tcp"
                            cidr_blocks      = [var.my_ip]
                        } 
                        egress {
                            from_port       = 0
                            to_port         = 0
                            protocol        = "-1"
                            cidr_blocks      = [var.my_ip]
                            prefix_list_ids = []
                        }
                        }
                        
                )
                for my_ip i add as variable and add on terraform.tfvars , ingress for coming traffic and egress for 
                outgoing form server to internet .. we will use same configuration , i use -1 for mean allow all protocol
                and i keep prefix_list_ids empty mean all ip or websites 
            * we can use default security group , rather than create new security group ,
                (
                    resource "aws_default_security_group" "default-sg-MM" {
                        vpc_id = aws_vpc.MM.id
                        ingress {
                            from_port        = 22 # here i can make range of ports like on from_port i will put 1 and to_port i will put 1000 if i need to open form 1 to 1000 range
                            to_port          = 22
                            protocol         = "tcp"
                            cidr_blocks      = [var.my_ip]
                        }

                        ingress {
                            from_port        = 8080 # here i can make range of ports like on from_port i will put 1 and to_port i will put 1000 if i need to open form 1 to 1000 range
                            to_port          = 8080
                            protocol         = "tcp"
                            cidr_blocks      = [var.my_ip]
                        } 
                        egress {
                            from_port       = 0
                            to_port         = 0
                            protocol        = "-1"
                            cidr_blocks      = [var.my_ip]
                            prefix_list_ids = []
                        }
                        tags = {
                            Name = "${var.env_prefix}-default_sg-MM"
                        }
                        }
                )
            - then we need to fetch image to be dynamically get latest image form aws we will use this 
                (
                    #fetch ami form aws latest one
                    data "aws_ami" "latest_ami" {
                        most_recent      = true # mean give latest images 
                        owners           = ["amazon"]

                        filter {
                            name   = "name"
                            values = ["amzn2-ami-*-x86_64-gp2"]
                        }

                        filter {
                            name   = "root-device-type"
                            values = ["ebs"]
                        }

                        filter {
                            name   = "virtualization-type"
                            values = ["hvm"]
                        }
                    }
                )
                we use filter to specify which ami i need 
                i can check id of ami by using output 
                (
                    output "ami-id" {
                        value = data.aws_ami.latest_ami.id                       
                        }
                )
            - then i wil create instance using that ami i fetch before 
                (
                    resource "aws_instance" "my-server" {
                        ami = data.aws_ami.latest_ami.id
                        instance_type = var.instance_type_size
                        subnet_id = aws_subnet.MM-sub-1.id
                        associate_public_ip_address = true
                        vpc_security_group_ids = [aws_default_security_group.default-sg-MM.id]
                        availability_zone = "us-east-2a" # i can use as variable and add in terraform.tfvars 
                        key_name = "auto-key-pair"
                        tags = {
                            Name = "${var.env_prefix}-my-server-MM"
                        }
                        }
                    - i can run script on server when i create to prepare server i will use "user_data"
                        (
                            resource "aws_instance" "my-server" {
                                ami = data.aws_ami.latest_ami.id
                                instance_type = var.instance_type_size
                                subnet_id = aws_subnet.MM-sub-1.id
                                associate_public_ip_address = true
                                vpc_security_group_ids = [aws_default_security_group.default-sg-MM.id]
                                availability_zone = "us-east-2a" # i can use as variable and add in terraform.tfvars 
                                key_name = "auto-key-pair"
                                user_data = <<EOF
                                                #!/bin/bash
                                                sudo yum update -y 
                                                sudo yum upgrade -y
                                                sudo yum install docker -y
                                                sudo systemctl start docker
                                                sudo groupadd docker
                                                sudo usermod -aG docker $USER
                                                newgrp docker
                                                docker run -p 8080:80 nginx
                                            EOF
                                tags = {
                                    Name = "${var.env_prefix}-my-server-MM"
                                }
                                }
                        )
                    - also i can run the script form file .. if i don't want alot of line on code for script , i will use same parameters
                        user_data 
                        (
                             user_data = file("prepare.sh")
                        )
                        and i will create the file on same folder for terraform 
                )
                here we create key manually and copy the name .. so we can create key pair automatically.
                using terraform we will use 
                (
                    - i need public_key .. this locally on my laptop in folder ".ssh" under name id_rsa.pub 
                      if i can't find public key i can generated by using this command "ssh-keygen"
                      then i will copy content of file and put on code 

                      resource "aws_key_pair" "auto-key-pair" {
                        key_name = "auto-key-pair"
                        public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDLnbBG844urxjjkBtv/64vfc1d4EAkMmqj+f6owziUYLVEgj9+1osFdGoh/9JsJtLEbK2pERC861SdDOlW1CB73fYy+CGPU89MKqQQHGeRsHdsclIkFJaexuJX4TOS44OifPLnz4mbnoPhqcsdGdr6Q6PIPpxoHkTxhH/ssubUIUx3zi3XGJUixwYLVsvZqMboLeZT03ZWTtHYnsAiHPYFDNldPMOhmRDcS/4Wt6kTugdWnKAAv5o8Wv0TFCqpXYe8hXTraFS91YdHvpGTbGYQjtanSKiw4jCyZrWBDl3nI1pU7WIQcD+8elZ0UrXhrvesPgdfHQ6FzOrnzKSlZIfU+sXYDyokOwqFJdCKXGzqxb4jXiP/KuHfbMxGmQFH81f6P97tO/1zzRxYjKptyvxGEKJ+Ntx1ZPLGGz3yAlsdEwJxHNey1tXbVLYYzws3dkGNymkkE9hQ+qfcAyo1TTox1pmnZz6//rgCrf87c7QKjy6/m5cN0++okoi2B7LwyI0= mohamedmamoon@Mohamed_Mamoon"
                        }

                        i can but as variables for public key and save on file terraform.tfvars 
                        and use the key_name on instance
                        - also i can mention the file of public key on folder .ssh by using this on code file 
                            public_key = "${file(var.public_key_path)}
                         and add this variable to the file terraform.tfvars like "public_key_path = "C:/Users/sadhiq/.ssh/id_rsa.pub"
                )
            - to run script on server remotely we can using " remote-exec" provisioner .. in this we can
                use inline mean list of command or we can use script file to run remotely on server , also is important 
                to specify for provisioner which server you want to run this command or script file
                (
                    - for specify connection to server we will use 
                        (
                              connection {
                                type = "ssh"
                                host = self.public_ip
                                user = "ec2-user"
                                private_key = file(var.private_key_path) # i will add as variable path for private key
                               }
                        )
                    - inline :
                        (
                            provisioner "remote-exec" {
                                inline = [
                                    "mkdir test" ,
                                    "cd test",
                                    "touch test.txt"
                                ]

                            }

                        )
                )
                we need to add those inside server configuration like :
                    (
                        resource "aws_instance" "my-server" {
                            ami = data.aws_ami.latest_ami.id
                            instance_type = var.instance_type_size
                            subnet_id = aws_subnet.MM-sub-1.id
                            associate_public_ip_address = true
                            vpc_security_group_ids = [aws_default_security_group.default-sg-MM.id]
                            availability_zone = "us-east-2a" # i can use as variable and add in terraform.tfvars 
                            key_name = "auto-key-pair"
                            #user_data = file("prepare.sh")

                            connection {
                                type = "ssh"
                                host = self.public_ip
                                user = "ec2-user"
                                private_key = file(var.private_key_path)
                            }
                            provisioner "remote-exec" {
                                inline = [
                                    "mkdir test" ,
                                    "cd test",
                                    "touch test.txt"
                                ]

                            }

                            tags = {
                                Name = "${var.env_prefix}-my-server-MM"
                            }
                            }
                    )
                    - script :
                        (
                            provisioner "remote-exec" {
                                script = file("prepare.sh")#this file must be on remote server not local

                            }        
                        )
                        for this we must first copy file form local to remote server , to do this we have
                        provisioner for copy file or directory to remote server
                        (
                              provisioner "file" {
                                source = "prepare.sh"
                                destination = "/home/ec2-user/prepare.sh"
                                
                            }
                            ---
                              provisioner "file" {
                                    source      = "script.sh"
                                    destination = "/tmp/script.sh"
                              }

                              provisioner "remote-exec" {
                                    inline = [
                                    "chmod +x /tmp/script.sh",
                                    "/tmp/script.sh args",
                                    ]
                              }
                        )
                    if we have multiple server we need to copy file form local we can add connection
                    on provisioner like :
                        (
                              provisioner "file" {
                                    source = "prepare.sh"
                                    destination = "/home/ec2-user/prepare.sh"

                                    connection {
                                    type = "ssh"
                                    host = self.public_ip
                                    user = "ec2-user"
                                    private_key = file(var.private_key_path)
                                    }
                                }
                        )
                also we can use local-exec provisioner to run scripts local on my laptop like if i want to print 
                public_ip for this server and save in file 
                    (
                        provisioner "local-exec" {
                            command = "echo The server's IP address is ${self.private_ip}"
                        }
                    )
             * module :
                (
                    - this mean we will structure the configuration and to be reuseable like function on programming language
                     we will organize code like we will create file for each thing like ( outputs , variables , providers , main)
                    - if create file for outputs , i can use those outputs of for other code by reference for modules like
                        "module.nameofmodule.outputsname.attribute" "module.my-app-subnet.subnet.id"
                    - we need to run first "terraform init" if module online it will bring all dependencies
                    (
                        module "my-app-subnet" {

                            source = "./modules/subnet"
                            vpc_id = var.vpc_id
                            default_route_table_id = var.default_route_table_id
                            vpc_cider_block = var.vpc_cider_block
                            subnet_cider_block = var.subnet_cider_block
                            env_prefix = var.env_prefix
                            
                            }

                    )
                    i specify where source file and then i pass variable i create in variable file in module and copy those variable to main variable file also 
                    
                    - we can use existing modules online in my project no need to write all configuration
                        https://registry.terraform.io/browse/modules?provider=aws this example for aws modules we can use


                )
            * store state file remotely :
                (
                    - if we run terraform on pipeline the state file will be on just that runner ,
                    and if i want later to run form my pc it will recreate all thing form beginning not complete what i have
                    so better to store the state.tfstate on remote and access that remote to check state 
                    i will store this file on S3 storage on aws , first i will create bucket
                        (
                            terraform {
                                required_version = ">= 0.12"
                                backend "s3" {
                                    bucket = "my_app-bucket"
                                    key = "my_app/state.tfstate"  
                                    region = "eu-west-3"
                                }
                                }
                        ) 
                    - after that i will do 
                        # terraform init
                    - if we have team work on terraform best practice is use remote state , and 
                    we need to check this remote location is support lock file . mean if one of team now
                    apply some change on state file other team wait until this update finish and write on state file
                    and then other team can apply there changes , S3 support that lock file , also dynamodb support
                    - best practice also to take backup for state file , in s3 we need to enable versioning on bucket
                    - if we have multiple env like dev , stage , production , we need state file for each environment
                    and keep that file on different location 


                )

            * Notes:
                (
                    - if i have multiple folder and each folder have files for specific environment like folder for stage, production, 
                    and we need to apply that files on that folder without make "cd " in that folder i will use 
                        > terraform -chdir=environment/production apply 

                        i use option "-chdir" this like change directory

                    - for debugging if i didn't know the error i will use :
                        > export TF_LOG=trace
                         the value can be one of the log levels (in order of decreasing verbosity) ""TRACE, DEBUG, INFO, WARN or ERROR"" to change the verbosity of the logs.

                         to disable debugging 
                        > export TF_LOG=off

                        and where to store this logs in which place , it should be give path for store using 
                         > export TF_LOG_PATH=./terraform.log

                        * i can store those option on file better than execute direct on cli because if close the terminal it will go on 
                        so i will create file powershell like "tf-logs.ps1"
                            {
                                $env:TF_LOG="TRACE"
                                $env:TF_LOG_PATH='{1}/logs/{0}-terraform.log' -f (Get-Date -Format yyyy-MM-dd-HH-mm-ss), $PSScriptRoot

                                terraform apply -auto-approve
                            }
                            1 i pas the directory and 0 i pass the data with specific Format

                            and then run 

                )

                    
                    

    }